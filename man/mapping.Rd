% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/13_mapping.R
\name{mapping}
\alias{mapping}
\title{mapping tag to loop on arguments}
\usage{
mapping(..args, .combine = rlang::missing_arg(),
  .init = rlang::missing_arg(), .final = NULL, .inorder = TRUE,
  .multicombine = FALSE, .maxcombine = NULL,
  .errorhandling = c("stop", "remove", "pass"), .packages = NULL,
  .export = NULL, .noexport = NULL, .verbose = FALSE)
}
\arguments{
\item{..args}{a list of sequences of arguments, can be a dataframe}

\item{.combine}{function that is used to process the tasks results as
    they generated.  This can be specified as either a function or
    a non-empty character string naming the function.
    Specifying 'c' is useful for concatenating the results into
    a vector, for example.  The values 'cbind' and 'rbind' can combine
    vectors into a matrix.  The values '+' and '*' can be used to
    process numeric data.
    By default, the results are returned in a list.}

\item{.init}{initial value to pass as the first argument of the
    \code{.combine} function.
    This should not be specified unless \code{.combine} is also specified.}

\item{.final}{function of one argument that is called to return final result.}

\item{.inorder}{logical flag indicating whether the \code{.combine}
    function requires the task results to be combined in the same order
    that they were submitted.  If the order is not important, then it
    setting \code{.inorder} to \code{FALSE} can give improved performance.
    The default value is \code{TRUE}.}

\item{.multicombine}{logical flag indicating whether the \code{.combine}
    function can accept more than two arguments.
    If an arbitrary \code{.combine} function is specified, by default,
    that function will always be called with two arguments.
    If it can take more than two arguments, then setting \code{.multicombine}
    to \code{TRUE} could improve the performance.
    The default value is \code{FALSE} unless the \code{.combine}
    function is \code{cbind}, \code{rbind}, or \code{c}, which are known
    to take more than two arguments.}

\item{.maxcombine}{maximum number of arguments to pass to the combine function.
    This is only relevant if \code{.multicombine} is \code{TRUE}.}

\item{.errorhandling}{specifies how a task evalution error should be handled.
    If the value is "stop", then execution will be stopped via
    the \code{stop} function if an error occurs.
    If the value is "remove", the result for that task will not be
    returned, or passed to the \code{.combine} function.
    If it is "pass", then the error object generated by task evaluation
    will be included with the rest of the results.  It is assumed that
    the combine function (if specified) will be able to deal with the
    error object.
    The default value is "stop".}

\item{.packages}{character vector of packages that the tasks depend on.
    If \code{ex} requires a \code{R} package to be loaded, this option
    can be used to load that package on each of the workers.
    Ignored when used with \code{\%do\%}.}

\item{.export}{character vector of variables to export.
    This can be useful when accessing a variable that isn't defined in the
    current environment.
    The default value in \code{NULL}.}

\item{.noexport}{character vector of variables to exclude from exporting.
    This can be useful to prevent variables from being exported that aren't
    actually needed, perhaps because the symbol is used in a model formula.
    The default value in \code{NULL}.}

\item{.verbose}{logical flag enabling verbose messages.  This can be
    very useful for trouble shooting.}
}
\description{
This a wrapper around \code{foreach::foreach} so that a call
\code{foreach(i=1:3, .combine = c) \%do\% exp(i)} can be written
\code{mapping(list(x=1:3), c)$exp()}
}
\examples{
mapping(list(times=1:3,x=4:6))$rep()
mapping(list(times=1:3))$rep(4:6)
mapping(list(x=1:3))$exp()
mapping(list(x=1:3), .combine = c)$exp()
area <- function(...) ..1 * ..2
transform(head(iris), Sepal.Area = mapping(head(iris), c)$area())
}
