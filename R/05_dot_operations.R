# 5 functions

modifying_dots1 <- function(fun){

  eval(substitute(
    env = list(FUN =  substitute(fun)),
    # we can't substitute alist so needed a workaround
    tag(args = alist(...vars=),{
      dots <- eval(substitute(alist(...)))
      # to use dplyr functions we need to convert to tibble, but a tibble doesn't
      # accept call columns so we nest them in lists and take them back out
      dots <- purrr::map(FUN(tibble::as_tibble(
        purrr::map(dots,list)), !!!...vars),1)
      # rebuild the call
      mc <- match.call(expand.dots = FALSE)
      mc[[1]] <- f
      dot_pos <- which(names(mc) == "...")
      mc <- as.call(c(as.list(mc[seq_len(dot_pos-1)]),
                      rlang::exprs(!!!dots),
                      as.list(mc[-seq_len(dot_pos)])))
      # then evaluate in calling environment
      eval.parent(mc)
    })))
}

modifying_dots2 <- function(fun){

  eval(substitute(
    env = list(FUN =  substitute(fun)),
    # we can't substitute alist so needed a workaround
    tag(args = alist(...exprs=),{
      dots1 <- eval(substitute(alist(...)))
      # to use dplyr functions we need to convert to tibble, but a tibble doesn't
      # accept call columns so we nest them in lists and take them back out
      dots2 <- purrr::map(FUN(tibble::as_tibble(
        purrr::map(dots1,list)),   !!!purrr::map(...exprs, list)),1) # !!!...exprs),1)
      dots2 <- purrr::map(dots2, ~do.call(substitute, list(.,dots1)))
      # rebuild the call
      mc <- match.call(expand.dots = FALSE)
      mc[[1]] <- f
      dot_pos <- which(names(mc) == "...")
      mc <- as.call(c(as.list(mc[seq_len(dot_pos-1)]),
                      rlang::exprs(!!!dots2),
                      as.list(mc[-seq_len(dot_pos)])))
      # then evaluate in calling environment
      eval.parent(mc)
    })))
}


# must use vars!

#' tags to modify content of dots
#'
#' tags inspired by dplyr functions to modify the dots of the call
#' @name selecting_dots
#' @param ...vars A list of columns generated by vars()
#' @param ...exprs A list of expressions generated by exprs()
#'
#' @examples
#' \dontrun{
#' library(dplyr)
#' library(purrr)
#' library(rlang)
#' # the functions can be used in regular calls
#' reversing_dots$paste0("a", "b")
#'
#' selecting_dots(vars(b2,starts_with("a")))$
#'   transform(head(cars,2), a1 = 1, b1 = 2, a2 = 3, b2 = speed *100)
#'
#' mutating_dots(exprs(foo = 1000 * bar))$
#'   mutate(head(cars,2), bar = speed * 10)
#'
#' # or with forwarded dots
#' fun <- function(...){
#'   print(
#'     selecting_dots(vars(b2,starts_with("a")))$
#'       mutate(head(cars,2), ...))
#'   print(
#'     renaming_dots(vars(foo = a1))$
#'       mutate(head(cars,2), ...))
#'   print(
#'     mutating_dots(exprs(a2 = 100*a2 + a1, foo = 1000 * b1))$
#'       mutate(head(cars,2), ...))
#'   print(
#'     transmuting_dots(exprs(a2 = 100*a2 + a1, foo = 1000 * b1))$
#'       mutate(head(cars,2), ...))
#'   print(
#'     reversing_dots$mutate(head(cars,2), ...))
#' }
#' fun(a1 = 1, b1 = 2, a2 = 3, b2 = 40)
#' }
NULL


#' @rdname selecting_dots
#' @export
selecting_dots <- modifying_dots1(dplyr::select)

#' @rdname selecting_dots
#' @export
renaming_dots <- modifying_dots1(dplyr::rename)

#' @rdname selecting_dots
#' @export
mutating_dots <- modifying_dots2(dplyr::mutate)

#' @rdname selecting_dots
#' @export
transmuting_dots <- modifying_dots2(dplyr::transmute)

#' @rdname selecting_dots
#' @export
reversing_dots <- tag({
  dots <- eval(substitute(alist(...)))
  dots <- rev(dots)
  # rebuild the call
  mc <- match.call(expand.dots = FALSE)
  mc[[1]] <- f
  dot_pos <- which(names(mc) == "...")
  mc <- as.call(c(as.list(mc[seq_len(dot_pos-1)]),
                  rlang::exprs(!!!dots),
                  as.list(mc[-seq_len(dot_pos)])))
  # then evaluate in calling environment
  eval.parent(mc)
})


# clean up!
rm(modifying_dots1)
rm(modifying_dots2)
