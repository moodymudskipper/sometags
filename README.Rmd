---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(tags)
```
# tags

This package consists of a collection of tags built using the functions and
principle designed and described in the package *tag*. See the read me at :
https://github.com/moodymudskipper/tag.

It is still largely in progress and subject to important changes such as 
addition /removal/ renaming of functions and arguments etc.

We showcase hereby the tags from the package.

Installation and setup :

```{r}
# devtools::install_github("moodymudskipper/tag")
# devtools::install_github("moodymudskipper/tags")
library(tags)
library(tidyverse,warn.conflicts = FALSE, quietly = TRUE, verbose = FALSE)
library(progress)
```

### Basic tags

#### `strictly` tag to adjust strictness of a call

```{r}
strictly(-1)$sqrt(-1)
```


#### `dbg` tag to debug a call

Will run `debugonce` on the input function.

```{r, eval = FALSE}
dbg$sample(5)
```

#### `logging` tag to log call and time it took

```{r}
logging$head(cars,2)
```

#### `trying` tag to try a call or if failure call alternate call

```{r}
trying$paste("hello","world", .else = "hi")
trying$paste("hello", world, .else = "hi")
trying$paste("hello", world, .else = "hi", .silent = TRUE)
```

#### `preserving_attr` tag to preserve attributes

```{r}
preserving_attr$map_dfr(head(iris,2),identity)
preserving_attr(incl_class = TRUE)$map_dfr(head(iris,2),identity)
```

### Tidy tags

#### `bng` tag to enable tidy evaluation or arguments

```{r}
u <- "speed"
v <- quote(dist)
w <- rlang::quo(time)
x <- list(a=c(1, 2), b=c(3, 4))
bng$transform(head(cars,2), !!w := !!v / !!rlang::sym(u), !!!x)
```

#### `lbd` tag to use formula notation on FUN arguments

```{r}
lbd$ave(c(1,2,4,3,NA),c(1,1,2,2,2),FUN = ~mean(.,na.rm=TRUE))
```

#### `on_self` tag to allow self referencing in arguments

```{r}
on_self$transform(head(iris,2), Petal.Width = ~1000*(.), Species = ~toupper(.))
on_self$summarize(iris, Petal.Width = ~median(.), Sepal.Length = ~mean(.))
```

#### `grp` tag to group and ungroup around another operation

```{r}
tbl_at_syms <- tags:::tbl_at_syms
grp$summarize(iris,meanSL = mean(Sepal.Length), .by="Species")
grp(.by="Species")$summarize(iris,meanSL = mean(Sepal.Length))
grp$summarize_all(iris, mean, .by="Species")
grp$slice(iris,1, .by="Species")
# unnamed groupings are not kept
grp$summarize(
  iris,meanSW = mean(Sepal.Width), .by= vars(Species, Sepal.Width > 3.2))
# named groupings are kept
grp$summarize(
  iris,meanSW = mean(Sepal.Width), .by= vars(Species, long_sepal = Sepal.Width > 3.2))
```

#### `rw` tag to apply a transformation rowwise

```{r}
rw$mutate(head(iris,3),X = mean(c(Sepal.Length, Sepal.Width)))
mutate(head(iris,3),X = mean(c(Sepal.Length, Sepal.Width)))
```

## *purrr* adverbs counterparts 

```{r}
safely2$log(10, otherwise = NA_real_)
safely2$log("a", otherwise = NA_real_)
safely2(otherwise = NA_real_)$log(10)
safely2(otherwise = NA_real_)$log("a")
```

```{r}
quietly2$sqrt(-1)
quietly2$sqrt(4)
```


```{r}
possibly2$log("a", otherwise = NA_real_)
possibly2$log(10, otherwise = NA_real_)
```

## functional sequences

This tag is not yet coded consistently to the other tags.

```{r}
fs(head)$dim()(iris)
fs$head(2)$gsub("h","X",.)(c("hello","hi","foo"))
```

## dot operations

`selecting_dots`, `renaming_dots`, `mutating_dots`, and `transmuting_dots` are wrappers around *dplyr* functions.

`reversing_dots` flips the arguments fed to the `...`.

```{r}
# the functions can be used in regular cal
reversing_dots$paste0("a", "b")
selecting_dots(vars(b2,starts_with("a")))$
  transform(head(cars,2), a1 = 1, b1 = 2, a2 = 3, b2 = speed *100)
mutating_dots(exprs(foo = 1000 * bar))$
  mutate(head(cars,2), bar = speed * 10)
# or with forwarded dots
fun <- function(...){
  print(
    selecting_dots(vars(b2,starts_with("a")))$
      mutate(head(cars,2), ...))
  print(
    renaming_dots(vars(foo = a1))$
      mutate(head(cars,2), ...))
  print(
    mutating_dots(exprs(a2 = 100*a2 + a1, foo = 1000 * b1))$
      mutate(head(cars,2), ...))
  print(
    transmuting_dots(exprs(a2 = 100*a2 + a1, foo = 1000 * b1))$
      mutate(head(cars,2), ...))
  print(
    reversing_dots$mutate(head(cars,2), ...))
}
fun(a1 = 1, b1 = 2, a2 = 3, b2 = 40)
```

## formal operations

**Work in progress**

`selecting_args`, `renaming_args`, `mutating_args`, and `transmuting_args` will change the formals of the functions.

They cannot be coded using the `tag` function only.

## using a progress bar

Detects the functional and displays a progress bar, using all the
available options from package *progress*.

```{r}
with_pb$map(1:5, ~{Sys.sleep(1);.x*2})
with_pb$lapply(1:5, function(x) {Sys.sleep(1);x*2})
```

## tracing and enclosing

`tracing` is modelled after `base::trace` and edits the body of its input function
while `enclosing` wraps the input function call inside a call to function `.around`, between statements `.before` and
`.after`.

```{r}
tracing(quote(print("hello")), exit = quote(print("good bye")))$mean(1:5)
enclosing(.before = print("hello"),
          .after = print(paste("result was:", .)),
          .around = suppressWarnings)$sqrt(-1)
```

## `in_parallel` tag to execute a call in another session

When using this tag the function and its arguments are evaluated and saved
so the call can be executed in another session, it allows things like 
displaying time elapsed or % of esimated time, or setting a timeout.

**work in progress** (but already works with limited features)

```{r}
u <- cars
v <- 3
fun <- function(y,m){
  Sys.sleep(5)
  head(y, m)
}
x <- in_parralel(.wait=FALSE)$fun(u,v)
x
y <- in_parralel$fun(u,v)
y
```


## `using` tag to evaluate call in a given environment

```{r}
using(iris)$ave(Sepal.Length,Species, FUN = mean)
vec <- c(1:2,a=2.5,3:4)
using(vec)[.>=a] # rather than ; vec[vec >= vec["a"]]
using(vec)[[.>=a]] # rather than ; vec >= vec["a"]
```

